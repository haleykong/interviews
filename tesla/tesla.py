# Tesla Python Assessment################################################################################ Importsfrom typing import Listimport pytestimport threading################################################################################ Question 1def state_machine(inputs):    """    State Machine    Write a function to implement the state machine show in the diagram    below.    * The initial state of the state machine should be A    * State machine inputs are expected to be a list of integers provided as    an argument to the function    * The function should output the current state of the state machine    Grading:        The majority of points are awarded for correct functionality. Full        points will only be awarded for a well-designed and scalable solution        of a state machine.    (See screenshot for state machine)    """    # Transition table of FSM    # transitions[current_state] = {k: v} where k = input and v = next_state    transition = {        "A": {2: "C", 3: "B"},        "B": {4: "A", 6: "C"},        "C": {1: "A", 5: "B"},    }    # Initialized state    state = "A"    # x: input, state: current state    for x in inputs:        if x in transition[state]:            state = transition[state][x]        else:            return "FAULT"    return statedef test_state_machine_example():    result = state_machine([2, 1, 3, 4, 2, 5])    assert result == "B"    result = state_machine([4])    assert result == "FAULT"################################################################################ Question 2def find_rotation(integers):    """    Given a list of monotonically increasing integers that has been rotated by    an arbitrary amount X, write a function to return the arbitrary rotation    amount X.    * input is expected to be a list of integers (of arbitrary length)    provided as an argument to the function    * output is an integer specifying the rotation amount    Grading:        - Majority of points are awarded for correct functionality.        - Full points are awarded for an efficient/scalable solution that is        O(logN). Note that the points for efficiency are <5% of the overall        test score, don't spend too much time on it    """    # Binary search for breakpoint value    # Initialize the leftmost and rightmost boundaries    l, r = 0, len(integers) - 1    while l < r:        mid = (l + r) // 2        # If the middle value is greater than the right boundary, breakpoint        # value is in right half        if integers[mid] > integers[r]:            l = mid + 1        # If the middle value is less than the right boundary, breakpoint        # value is in left half        else:            r = mid    return ldef test_find_rotation_example():    assert 6 == find_rotation([5, 6, 7, 8, 9, 10, 2, 3, 4])    assert 3 == find_rotation([9, 12, 17, 2, 3, 5, 6, 8])################################################################################ Question 3def threaded_numbers(n):    """    Given a positive integer n, return a list with numbers from 1 to n with    the following constraint:    Use 2 threads, one that produces the even numbers and another thread that    produces the odd numbers.    Grading:        - Do not perform any sorting, merging, or indexed list insertion to        ensure ordering of the output. The threads must cooperate to produce        the output in order by appending one element at a time to a shared        list object. They cannot operate independently.        - The function should work for an arbitrary positive integer input.    """    result = []    x = 1  # Current number    # Create flags to communicate between the threads    odd_flag = threading.Event()    even_flag = threading.Event()    # Initial flag set due to initial number being 1    odd_flag.set()    # Append odd number to list    def append_odd():        nonlocal x        while x <= n:            odd_flag.wait()            if x % 2 == 1 and x <= n:                result.append(x)                x += 1            odd_flag.clear()            even_flag.set()    # Append even number to list    def append_even():        nonlocal x        while x <= n:            even_flag.wait()            if x % 2 == 0 and x <= n:                result.append(x)                x += 1            even_flag.clear()            odd_flag.set()    # Create two threads    odd_thread = threading.Thread(target=append_odd)    even_thread = threading.Thread(target=append_even)    # Start both threads    odd_thread.start()    even_thread.start()    # Wait for both threads to finish    odd_thread.join()    even_thread.join()    return resultdef test_threaded_numbers_example():    assert [1, 2, 3, 4, 5] == threaded_numbers(5)################################################################################ Question 4class Node:    """    Class representing a node in the tree for Q4    """    def __init__(self, name, children=[]):        self.children = children        self.name = namedef create_tree():    """    Creates the example tree (see screenshot)    """    return Node(        1,        [            Node(2, [Node(5), Node(6, [Node(10)])]),            Node(3, [Node(7, [Node(11), Node(12)])]),            Node(3, [Node(8, [Node(13)]), Node(9, [Node(14)])])        ],    )def ancestry_path(target_node_name, root_node):    """    Given the root Node of a tree and the name of a target Node, determine the    ancestry path from the root Node to the target Node with the specified    name, returned as a list of Node noames. You may assume that Node names in    the tree are unique (return the first valid ancestry path that is found).    Use the create_tree() method defined above to test your code. You may    create additional trees to further test your code, but this is not    required.    Grading:        - The solution should be flexible enough to solve for deeper/wider        trees, not just the tree in the example        - For full marks, the solution should consider/minimize CPU and        memory usage    """    def dfs(curr_node, target_node_name, path):        if not curr_node:            return False        path.append(curr_node.name)        # If current node name is the target node name, return True        if curr_node.name == target_node_name:            return True        # Check each child        for child in curr_node.children:            if dfs(child, target_node_name, path):                return True        # If target node name is not found, remove the current node from path        path.pop()        return False    ancestry_path = []    if dfs(root_node, target_node_name, ancestry_path):        return ancestry_path    else:        return Nonedef test_ancestry_path_example():    assert [1, 3, 7, 11] == ancestry_path(11, create_tree())